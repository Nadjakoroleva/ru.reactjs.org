---
id: faq-state
title: Component State
permalink: docs/faq-state.html
layout: docs
category: FAQ
---

### Что делает `setState`? {#what-does-setstate-do}

`setState()` следит за изменением `состояния` компонента. `Состояние` — это объект. Когда состояние меняется, компонент рендерится повторно.

### Какая разница между `state` и `props`? {#what-is-the-difference-between-state-and-props}

[`props`](/docs/components-and-props.html) (сокращённо от англ. "properties" — свойства) и [`state`](/docs/state-and-lifecycle.html) обычными JavaScript-объектами. Несмотря на то, что оба содержат информацию, которая влияет на то, что увидим после рендера, есть существенное различие: `props` передаются *в* компонент (ведут себя как параметры функции), в то время как `state` находится *внутри* компонента (ведут себя как переменные, которые объявлены внутри функции).

Несколько полезных ресурсов для дальнейшего изучения, в каких случаях использовать `props`, а в каких — `state`:

- [Props vs State](https://github.com/uberVU/react-guide/blob/master/props-vs-state.md)
- [ReactJS: Props vs State](http://lucybain.com/blog/2016/react-state-vs-pros/)

### Почему `setState` дает неверное значение? {#why-is-setstate-giving-me-the-wrong-value}

В React, и `this.props` и `this.state` представляют значения, которые *уже были отрисованы*, например, то, что видите на экране.

Вызовы `setState` являются асинхронными, поэтому не стоит рассчитывать, что `this.state` отобразит новое значение мгновенно после вызова `setState`. Необходимо добавить функцию, которая сработает только после обновления состояния, если нужно получить новое значение, основанное на текущем состоянии (ниже подробный пример).

Пример кода, который *не* будет вести себя, как ожидаем:

```jsx
incrementCount() {
  // Примечание: это *не* сработает, как ожидалось.
  this.setState({count: this.state.count + 1});
}

handleSomething() {
  // Допустим, что `this.state.count` начинается с 0.
  this.incrementCount();
  this.incrementCount();
  this.incrementCount();
  // Когда React делает последующий рендер компонента, `this.state.count` будет 1, хотя мы ожидаем 3.

  // Такое поведение происходит потому, что функция `incrementCount()` берет свое значение из `this.state.count`,
  // но React не обновляет `this.state.count` пока компонент не отрендерится снова.
  // Получается, что `incrementCount()` обращается к текущему значению `this.state.count`, а это 0 каждый раз, и добавляет 1.

  // Как исправить это поведение — разберем ниже!
}
```

Ниже о том, как исправить это поведение.

### Как я могу обновить состояние со значением, которое приходит из текущего состояния? {#how-do-i-update-state-with-values-that-depend-on-the-current-state}

Нужно добавить функцию вместо объекта к `setState`, которая будет срабатывать только на самой последней версии состояния (пример ниже).

### Какая разница между добавлением объекта или функции к `setState`? {#what-is-the-difference-between-passing-an-object-or-a-function-in-setstate}

Добавление функции дает вам доступ к текущему состоянию внутри самой функции. Так как `setState` вызовы «сгруппированы», это помогает связать изменения и дает уверенность, что они будут идти друг за другом, а не конфликтовать.

```jsx
incrementCount() {
  this.setState((state) => {
    // Важно: используем `state` вместо `this.state` при обновлении.
    return {count: state.count + 1}
  });
}

handleSomething() {
  // Возьмем снова для примера, что `this.state.count` начинается с 0.
  this.incrementCount();
  this.incrementCount();
  this.incrementCount();

  // Если посмотреть на значение `this.state.count` сейчас, это будет все еще 0.
  // Но когда React отрендерит компонент снова, это будет 3.
}
```

[Прочитать больше про setState](/docs/react-component.html#setstate)

### Когда `setState` асинхронный? {#when-is-setstate-asynchronous}

В данный момент, `setState` асинхронный внутри event handlers (англ. «обработчик событий»).

Это дает гарантию, например, когда `Родитель` и `Ребенок` вызывают `setState` во время клика, `Ребенок` не будет рендерится дважды. Вместо этого, React оставляет обновление состояния в самый конец событий в браузере. Это очень сильно помогает в повышении производительности в больших приложениях.

Но не стоит полагаться на такое поведение полностью. В будущих версиях React будет способен получать обновления по дефолту и другими способами.

### Почему React не обновляет `this.state` синхронно? {#why-doesnt-react-update-thisstate-synchronously}

Как говорилось ранее, React намеренно "ждет" пока все компоненты вызовут `setState()` в своих обработчиках событий прежде чем начать повторный рендер. Это избавляет от ненужных повторных рендеров.

Но если все же остался вопрос, почему React не может просто сразу обновить `this.state` без повтороного рендеринга?

На это есть две причины:

- Это нарушит логику работы `props` и `state`, и станет причиной многих багов, которые будет сложно исправлять.
- Это сделало бы невозможным реализацию некоторых возможностей, над которыми мы сейчас работаем.

Этот [GitHub комментарий](https://github.com/facebook/react/issues/11527#issuecomment-360199710) рассматривает конкретные примеры, которые помогут глубже изучить этот вопрос.

### Стоит ли мне использовать библиотеки Redux или MobX? {#should-i-use-a-state-management-library-like-redux-or-mobx}

[Возможно.](https://redux.js.org/faq/general#when-should-i-use-redux)

Но вообще будет здорово сначала изучить и познакомиться с React, прежде чем переходить к библиотекам. Можно сделать готовое рабочее приложение, используя только React.
